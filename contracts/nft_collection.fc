#include "imports/stdlib.fc";
#include "imports/op-codes.fc";
#include "imports/params.fc";

global slice owner_address; ;; 267
global slice jetton_wallet_address; ;; 267
global int last_index; ;; 32
global int buyer_limit_silver; ;; 32
global int ton_price_silver; ;; 124
global int jetton_price_gold; ;; 124
global cell nft_item_code; ;; ref 
global cell whitelist;  ;; ref
global cell royalty_params_data; ;; ref

global cell content_collection; ;; ref
global cell content_item_gold; ;; ref
global cell content_item_silver; ;; ref


int min_gas_amount() asm "200000000 PUSHINT"; ;; 0.2 TON

;; errors 
const int error::not_enough_ton = 800;
const int error::sale_all_nft = 801;
const int error::not_owner = 802;
const int error::incorrect_index = 803;


() load_data() impure inline {
    var ds = get_data().begin_parse(); ;; Bits = 267 + 267 + 32 + 32 + 124 + 124 + 1 = 846. Refs = 4.
    owner_address = ds~load_msg_addr();
    jetton_wallet_address = ds~load_msg_addr();
    last_index = ds~load_uint(32);
    buyer_limit_silver = ds~load_uint(32);
    ton_price_silver = ds~load_coins();
    jetton_price_gold = ds~load_coins();
    nft_item_code = ds~load_ref();
    whitelist = ds~load_dict();
    royalty_params_data = ds~load_ref();

    var ds2 = ds~load_ref().begin_parse(); ;; Bits = 0. Refs = 4.
    content_collection = ds2~load_ref();
    content_item_gold = ds2~load_ref();
    content_item_silver = ds2~load_ref();
}


() save_data() impure {
    set_data(
        begin_cell()
            .store_slice(owner_address)
            .store_slice(jetton_wallet_address)
            .store_uint(last_index, 32)
            .store_uint(buyer_limit_silver, 32)
            .store_coins(ton_price_silver)
            .store_coins(jetton_price_gold)
            .store_ref(nft_item_code)
            .store_dict(whitelist)
            .store_ref(royalty_params_data)
            .store_ref(
                begin_cell()
                    .store_ref(content_collection)
                    .store_ref(content_item_gold)
                    .store_ref(content_item_silver)
                .end_cell()
            )
        .end_cell()
    );
}

cell calculate_nft_item_state_init(int item_index, cell nft_item_code) {
  cell data = begin_cell().store_uint(item_index, 64).store_slice(my_address()).end_cell();
  return begin_cell().store_uint(0, 2).store_dict(nft_item_code).store_dict(data).store_uint(0, 1).end_cell();
}

slice calculate_nft_item_address(int wc, cell state_init) {
  return begin_cell().store_uint(4, 3)
                     .store_int(wc, 8)
                     .store_uint(cell_hash(state_init), 256)
                     .end_cell()
                     .begin_parse();
}

() deploy_nft_item(int item_index, slice owner, cell content_item) impure {
  cell state_init = calculate_nft_item_state_init(item_index, nft_item_code);
  slice nft_address = calculate_nft_item_address(workchain(), state_init);
  var msg = begin_cell()
            .store_uint(0x18, 6)
            .store_slice(nft_address)
            .store_coins(30000000)
            .store_uint(4 + 2 + 1, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1)
            .store_ref(state_init)
            .store_ref(begin_cell()
                .store_slice(owner)
                .store_ref(content_item)
                .end_cell());
  send_raw_message(msg.end_cell(), 1); ;; pay transfer fees separately, revert on errors
}

() send_royalty_params(slice to_address, int query_id, slice data) impure inline {
  var msg = begin_cell()
    .store_uint(0x10, 6) ;; nobounce - int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool packages:MsgAddress -> 011000
    .store_slice(to_address)
    .store_coins(0)
    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
    .store_uint(op::report_royalty_params(), 32)
    .store_uint(query_id, 64)
    .store_slice(data);
  send_raw_message(msg.end_cell(), 64); ;; carry all the remaining value of the inbound message
}

() send_ton(slice address, int amount, int send_mode) impure inline {

    var msg = begin_cell()
        .store_uint(0x10, 6) ;; nobounce
        .store_slice(address)
        .store_coins(amount)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .end_cell();

    send_raw_message(msg, send_mode); ;; 2 + 1
}

() send_jettons(slice jetton_wallet, slice address, int amount, slice response_address) impure inline {

    var msg_payload = begin_cell()
        .store_uint(jetton::transfer(), 32) ;; transfer
        .store_uint(0, 64)
        .store_coins(amount)
        .store_slice(address)
        .store_slice(response_address)
        .store_int(0, 1)
        .store_coins(0)
        .store_uint(0, 1)
        .end_cell();

    var msg = begin_cell()
        .store_uint(0x10, 6) ;; nobounce
        .store_slice(jetton_wallet)
        .store_coins(40000000) ;; 0.04 TON
        .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_ref(msg_payload)
        .end_cell();

    send_raw_message(msg, 3);
}


() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { ;; ignore empty messages
        return ();
    }
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);

    if (flags & 1) { ;; ignore all bounced messages
        return ();
    }
    slice sender_address = cs~load_msg_addr();

    int op = in_msg_body~load_uint(32);
    int query_id = in_msg_body~load_uint(64);

    load_data();

    if (op == op::get_royalty_params()) {
        send_royalty_params(sender_address, query_id, royalty_params_data.begin_parse());
        return ();
    }

    if ((op == 1)) { ;; buy nft_silver for TON 
        throw_if(error::not_enough_ton, msg_value < ton_price_silver);
        throw_unless(error::sale_all_nft, last_index < buyer_limit_silver);
        deploy_nft_item(last_index, sender_address, content_item_silver);
        last_index += 1;
        raw_reserve(100000000, 0);
        send_ton(owner_address, 0, 128);
        save_data();
        return ();
    }

    if ((op == jetton::transfer_notification())) { ;; buy nft_gold for jetton

        int jetton_amount = in_msg_body~load_coins();
        slice buyer_address = in_msg_body~load_msg_addr();

        ifnot (equal_slices(sender_address, jetton_wallet_address) | (msg_value >= min_gas_amount())) { ;; так как чуваки будут пытатся нас обмануть мы не будем им ничего возращать 
            return ();
        }

        (whitelist, _, int success) = dict_delete_get?(whitelist, 267, buyer_address);

        if (jetton_amount < jetton_price_gold) {
            success = 0;
        }

        if (success) {
            deploy_nft_item(last_index, buyer_address, content_item_gold);
            last_index += 1;
            send_jettons(jetton_wallet_address, owner_address, jetton_amount, owner_address);
            save_data();
            return ();
        } else { ;; возрат средств 
            send_jettons(jetton_wallet_address, buyer_address, jetton_amount, buyer_address);
            return ();
        }

    }

    throw_unless(error::not_owner, equal_slices(sender_address, owner_address));


    ;;;надо поправить

    if (op == 2) { ;; deploy new nft
      int item_index = in_msg_body~load_uint(32);
      slice owner = in_msg_body~load_msg_addr();
      cell content = in_msg_body~load_ref();
      throw_unless(error::incorrect_index, item_index <= last_index);
      var is_last = item_index == last_index;
      deploy_nft_item(item_index, owner, content);
      if (is_last) {
        last_index += 1;
        save_data();
      }
      return ();
    }

    if (op == 3) { ;; change owner and buyer_limit_silver
        owner_address = in_msg_body~load_msg_addr();
        buyer_limit_silver = in_msg_body~load_uint(32);
        save_data();
        return ();
    }

    if (op == 4) { ;; change price
        ton_price_silver = in_msg_body~load_coins();
        jetton_price_gold = in_msg_body~load_coins();
        save_data();
        return ();
    }

    if (op == 5) { ;; send ton 
        slice address = in_msg_body~load_msg_addr();
        int amount = in_msg_body~load_coins();
        int send_mode = in_msg_body~load_uint(16);
        send_ton(address,amount,send_mode);
        return ();
    }

    if (op == 6) { ;; send jetton
        slice jetton_wallet_address = in_msg_body~load_msg_addr();
        slice address = in_msg_body~load_msg_addr();
        int amount = in_msg_body~load_coins();
        send_jettons(jetton_wallet_address, address, amount, address);
        return ();
    }

    if (op == 7) {
        jetton_wallet_address = in_msg_body~load_msg_addr();
        save_data();
        return ();
    }

    if (op == 8) {
        (cell new_data, cell new_code) = (in_msg_body~load_ref(), in_msg_body~load_ref());
        set_data(new_data);
        set_code(new_code);
        return ();
    }

    throw(0xffff);
}

;; Get methods

(int, cell, slice) get_collection_data() method_id {
    load_data();
    slice cs = content_collection.begin_parse();
    return (last_index, cs~load_ref(), owner_address);
}

slice get_nft_address_by_index(int index) method_id {
    load_data();
    cell state_init = calculate_nft_item_state_init(index, nft_item_code);
    return calculate_nft_item_address(0, state_init);
}

(int, int, slice) royalty_params() method_id {
    load_data();
    slice rs = royalty_params_data.begin_parse();
    return (rs~load_uint(16), rs~load_uint(16), rs~load_msg_addr());
}

cell get_nft_content(int index, cell individual_nft_content) method_id {
  load_data();
  slice cs = content_collection.begin_parse();
  cs~load_ref();
  slice common_content = cs~load_ref().begin_parse();
  return (begin_cell()
                      .store_uint(1, 8) ;; offchain tag
                      .store_slice(common_content)
                      .store_ref(individual_nft_content)
          .end_cell());
}

(
    slice, int, int, int, int, cell, cell, cell, slice
) get_all_information() method_id {
    load_data();
    slice cs = content_collection.begin_parse();
    return (
        owner_address,
        last_index,
        buyer_limit_silver,
        ton_price_silver,
        jetton_price_gold,
        cs~load_ref(), ;; content_collection
        content_item_gold,
        content_item_silver,
        jetton_wallet_address
    );
}